#!/usr/bin/env bash
# database-init.sh - Database initialization module
# POSIX-compliant, no Bash 4+ features

# Generate PostgreSQL initialization scripts
generate_postgres_init() {
  local project_name="${1:-nself}"
  local postgres_db="${POSTGRES_DB:-$project_name}"
  local postgres_user="${POSTGRES_USER:-postgres}"

  # Create postgres init directory
  mkdir -p postgres/init

  # Generate main initialization script
  generate_init_sql "$postgres_db" "$postgres_user"

  # Generate extensions script
  generate_extensions_sql

  # Generate schemas script
  generate_schemas_sql

  # Generate Hasura metadata if enabled
  if [[ "${HASURA_ENABLED:-false}" == "true" ]]; then
    generate_hasura_init_sql
    generate_superadmin_seed_sql
  fi

  # Generate auth tables if enabled AND not using nHost auth
  # nHost auth manages its own schema, so skip if using the default image
  if [[ "${AUTH_ENABLED:-false}" == "true" ]] && [[ "${AUTH_USE_FALLBACK:-false}" == "true" ]]; then
    generate_auth_init_sql
  fi

  return 0
}

# Generate main init.sql
generate_init_sql() {
  local postgres_db="${1:-nself}"
  local postgres_user="${2:-postgres}"
  # Sanitize database name (replace hyphens with underscores)
  local safe_db_name=$(echo "$postgres_db" | tr '-' '_')

  cat > postgres/init/00-init.sql <<EOF
-- PostgreSQL Initialization Script
-- Generated by nself build

-- Create database if not exists
SELECT 'CREATE DATABASE "${safe_db_name}"'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${safe_db_name}')\\gexec

-- Grant all privileges
GRANT ALL PRIVILEGES ON DATABASE "${safe_db_name}" TO ${postgres_user};

-- Create MLflow database if MLflow is enabled
EOF

  if [[ "${MLFLOW_ENABLED:-false}" == "true" ]]; then
    cat >> postgres/init/00-init.sql <<EOF

-- Create MLflow database if not exists
SELECT 'CREATE DATABASE mlflow'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'mlflow')\\gexec
GRANT ALL PRIVILEGES ON DATABASE mlflow TO ${postgres_user};
EOF
  fi

  cat >> postgres/init/00-init.sql <<EOF

-- Connect to the database
\\c "${safe_db_name}"

-- Create default schema
CREATE SCHEMA IF NOT EXISTS public;
GRANT ALL ON SCHEMA public TO ${postgres_user};
GRANT ALL ON ALL TABLES IN SCHEMA public TO ${postgres_user};
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ${postgres_user};
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO ${postgres_user};

-- Always create auth schema (required for auth service)
CREATE SCHEMA IF NOT EXISTS auth;
GRANT ALL ON SCHEMA auth TO ${postgres_user};
GRANT ALL ON ALL TABLES IN SCHEMA auth TO ${postgres_user};
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO ${postgres_user};
GRANT ALL ON ALL FUNCTIONS IN SCHEMA auth TO ${postgres_user};

-- Always create storage schema (may be needed later)
CREATE SCHEMA IF NOT EXISTS storage;
GRANT ALL ON SCHEMA storage TO ${postgres_user};
GRANT ALL ON ALL TABLES IN SCHEMA storage TO ${postgres_user};
GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO ${postgres_user};
GRANT ALL ON ALL FUNCTIONS IN SCHEMA storage TO ${postgres_user};
EOF

  return 0
}

# Generate extensions script
generate_extensions_sql() {
  local extensions="${POSTGRES_EXTENSIONS:-uuid-ossp,pgcrypto}"
  local postgres_db="${POSTGRES_DB:-nself}"
  local safe_db_name=$(echo "$postgres_db" | tr '-' '_')

  cat > postgres/init/01-extensions.sql <<EOF
-- PostgreSQL Extensions
-- Generated by nself build

\\c ${safe_db_name}

-- Enable UUID support
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enable cryptographic functions
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Enable JSONB operators (commented out - requires Python runtime)
-- CREATE EXTENSION IF NOT EXISTS "jsonb_plpython3u" CASCADE;
EOF

  # Add custom extensions if specified
  if [[ -n "$extensions" ]]; then
    # Split comma-separated extensions
    local IFS=','
    for ext in $extensions; do
      # Skip already added extensions
      case "$ext" in
        uuid-ossp|pgcrypto) continue ;;
        pgvector)
          echo "CREATE EXTENSION IF NOT EXISTS vector;" >> postgres/init/01-extensions.sql
          ;;
        postgis)
          echo "CREATE EXTENSION IF NOT EXISTS postgis;" >> postgres/init/01-extensions.sql
          echo "CREATE EXTENSION IF NOT EXISTS postgis_topology;" >> postgres/init/01-extensions.sql
          ;;
        pg_cron)
          echo "CREATE EXTENSION IF NOT EXISTS pg_cron;" >> postgres/init/01-extensions.sql
          ;;
        timescaledb)
          echo "CREATE EXTENSION IF NOT EXISTS timescaledb;" >> postgres/init/01-extensions.sql
          ;;
        *)
          echo "CREATE EXTENSION IF NOT EXISTS \"$ext\";" >> postgres/init/01-extensions.sql
          ;;
      esac
    done
  fi

  return 0
}

# Generate schemas script
generate_schemas_sql() {
  local postgres_db="${POSTGRES_DB:-nself}"
  local safe_db_name=$(echo "$postgres_db" | tr '-' '_')

  cat > postgres/init/02-schemas.sql <<EOF
-- Database Schemas
-- Generated by nself build

\\c ${safe_db_name}

-- Create auth schema if auth is enabled
CREATE SCHEMA IF NOT EXISTS auth;

-- Create storage schema if storage is enabled
CREATE SCHEMA IF NOT EXISTS storage;

-- Create Hasura schema
CREATE SCHEMA IF NOT EXISTS hdb_catalog;

-- Grant permissions
GRANT ALL ON SCHEMA auth TO ${POSTGRES_USER:-postgres};
GRANT ALL ON SCHEMA storage TO ${POSTGRES_USER:-postgres};
GRANT ALL ON SCHEMA hdb_catalog TO ${POSTGRES_USER:-postgres};
EOF

  # Add app-specific schemas if multi-app
  local app_count="${FRONTEND_APP_COUNT:-0}"
  if [[ "$app_count" -gt 0 ]]; then
    echo "" >> postgres/init/02-schemas.sql
    echo "-- App-specific schemas" >> postgres/init/02-schemas.sql

    local i=1
    while [[ $i -le $app_count ]]; do
      local prefix_var="FRONTEND_APP_${i}_TABLE_PREFIX"
      local prefix="${!prefix_var:-}"

      if [[ -n "$prefix" ]]; then
        # Remove trailing underscore if present
        local schema_name="${prefix%_}"
        echo "CREATE SCHEMA IF NOT EXISTS \"$schema_name\";" >> postgres/init/02-schemas.sql
        echo "GRANT ALL ON SCHEMA \"$schema_name\" TO \${POSTGRES_USER:-postgres};" >> postgres/init/02-schemas.sql
      fi

      i=$((i + 1))
    done
  fi

  return 0
}

# Generate Hasura initialization
generate_hasura_init_sql() {
  local postgres_db="${POSTGRES_DB:-nself}"
  local safe_db_name=$(echo "$postgres_db" | tr '-' '_')

  cat > postgres/init/10-hasura.sql <<EOF
-- Hasura Initialization
-- Generated by nself build

\\c ${safe_db_name}

-- Create Hasura catalog schema
CREATE SCHEMA IF NOT EXISTS hdb_catalog;

-- Create Hasura views schema
CREATE SCHEMA IF NOT EXISTS hdb_views;

-- Grant permissions
GRANT ALL ON SCHEMA hdb_catalog TO ${POSTGRES_USER:-postgres};
GRANT ALL ON SCHEMA hdb_views TO ${POSTGRES_USER:-postgres};
GRANT ALL ON ALL TABLES IN SCHEMA hdb_catalog TO ${POSTGRES_USER:-postgres};
GRANT ALL ON ALL SEQUENCES IN SCHEMA hdb_catalog TO ${POSTGRES_USER:-postgres};
GRANT ALL ON ALL FUNCTIONS IN SCHEMA hdb_catalog TO ${POSTGRES_USER:-postgres};
EOF

  return 0
}

# Generate Auth initialization
generate_auth_init_sql() {
  local postgres_db="${POSTGRES_DB:-nself}"
  local safe_db_name=$(echo "$postgres_db" | tr '-' '_')

  cat > postgres/init/20-auth.sql <<EOF
-- Auth Tables Initialization
-- Generated by nself build

\\c ${safe_db_name}

-- Ensure auth schema exists
CREATE SCHEMA IF NOT EXISTS auth;

-- Create users table
CREATE TABLE IF NOT EXISTS auth.users (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    email text UNIQUE NOT NULL,
    email_verified boolean DEFAULT false,
    password_hash text,
    display_name text,
    avatar_url text,
    locale text DEFAULT 'en',
    disabled boolean DEFAULT false,
    default_role text NOT NULL DEFAULT 'user',
    metadata jsonb DEFAULT '{}',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Create refresh tokens table
CREATE TABLE IF NOT EXISTS auth.refresh_tokens (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    refresh_token text NOT NULL UNIQUE,
    expires_at timestamptz NOT NULL,
    created_at timestamptz DEFAULT now()
);

-- Create roles table
CREATE TABLE IF NOT EXISTS auth.roles (
    role text PRIMARY KEY,
    description text,
    created_at timestamptz DEFAULT now()
);

-- Insert default roles
INSERT INTO auth.roles (role, description) VALUES
    ('user', 'Default user role'),
    ('admin', 'Administrator role'),
    ('anonymous', 'Anonymous/public role')
ON CONFLICT (role) DO NOTHING;

-- Create user_roles junction table
CREATE TABLE IF NOT EXISTS auth.user_roles (
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role text NOT NULL REFERENCES auth.roles(role) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    PRIMARY KEY (user_id, role)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_users_email ON auth.users(email);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON auth.refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token ON auth.refresh_tokens(refresh_token);
CREATE INDEX IF NOT EXISTS idx_user_roles_user_id ON auth.user_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_role ON auth.user_roles(role);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION auth.set_updated_at()
RETURNS TRIGGER AS \$\$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS set_users_updated_at ON auth.users;
CREATE TRIGGER set_users_updated_at
    BEFORE UPDATE ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION auth.set_updated_at();
EOF

  return 0
}

# Generate Superadmin Seed
generate_superadmin_seed_sql() {
  local nself_root="${NSELF_ROOT:-.}"
  local template="$nself_root/src/templates/hasura/seed_superadmin.sql.template"
  local output="postgres/init/99-seed-superadmin.sql"

  if [[ -f "$template" ]]; then
    log_info "Generating superadmin seed script..."
    cp "$template" "$output"
    
    # Render variables
    sed -i "s/{{POSTGRES_DB}}/${POSTGRES_DB:-nself}/g" "$output"
    sed -i "s/{{SUPERADMIN_EMAIL}}/${SUPERADMIN_EMAIL:-admin@localhost}/g" "$output"
    sed -i "s/{{SUPERADMIN_PASSWORD}}/${SUPERADMIN_PASSWORD:-admin123}/g" "$output"
  else
    log_warning "Superadmin seed template not found at $template"
  fi

  return 0
}

# Export functions
export -f generate_postgres_init
export -f generate_init_sql
export -f generate_extensions_sql
export -f generate_schemas_sql
export -f generate_hasura_init_sql
export -f generate_auth_init_sql
export -f generate_superadmin_seed_sql